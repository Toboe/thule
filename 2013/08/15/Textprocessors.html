<h1>Serches</h1>

<p>awk &#39;NR==2&#39; buildinstructins
find . -iname &#39;<em>&#39; -print | sed -n -E -e &#39;s/.</em>mp3/&amp;/p&#39; -e &#39;s/.<em>wav/&amp;/p&#39; -e &#39;s/.</em>wma/&amp;/p&#39; &gt; appo.m3u
find . -iregex &#39;.*.(mp3|wav|wma)&#39; -print &gt; app.m3u</p>

<h1>VIM:</h1>

<p>:s/foo/bar/g
    Change each &#39;foo&#39; to &#39;bar&#39; in the current line.
:%s/foo/bar/g   Change each &#39;foo&#39; to &#39;bar&#39; in all lines.
:5,12s/foo/bar/g    Change each &#39;foo&#39; to &#39;bar&#39; for all lines from line 5 to line 12 inclusive.
:&#39;a,&#39;bs/foo/bar/g   Change each &#39;foo&#39; to &#39;bar&#39; for all lines from mark a to mark b inclusive (see Note below).
:&#39;&lt;,&#39;&gt;s/foo/bar/g   When compiled with +visual, change each &#39;foo&#39; to &#39;bar&#39; for all lines within a visual selection. Vim automatically appends the visual selection range (&#39;&lt;,&#39;&gt;) for any ex command when you select an area and enter :. Also, see Note below.
:.,$s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; for all lines from the current line (.) to the last line ($) inclusive.
:.,+2s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; for the current line (.) and the two next lines (+2).
:g/^baz/s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; in each line starting with &#39;baz&#39;.</p>

<p>When searching:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">., *, \, [, ], ^, and $ are metacharacters. 
+, ?, |, {, }, (, and ) must be escaped to use their special function. 
\/ is / (use backslash + forward slash to search for forward slash) 
\t is tab, \s is whitespace 
\n is newline, \r is CR (carriage return = Ctrl-M = ^M) 
\{#\} is used for repetition. /foo.\{2\} will match foo and the two following characters. The \ is not required on the closing } so /foo.\{2} will do the same thing. 
\(foo\) makes a backreference to foo. Parenthesis without escapes are literally matched. Here the \ is required for the closing \). 
</code></pre></div>
<p>When replacing:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">\r is newline, \n is a null byte (0x00). 
\&amp; is ampersand (&amp; is the text that matches the search pattern). 
\1 inserts the text of the first backreference. \2 inserts the second backreference, and so on. 
</code></pre></div>
<p>Insert newline without entering insert mode
nmap <S-Enter> O<Esc><br>
shift
nmap <CR> o<Esc></p>

<p>each time you hit Ctrl-W, you delete the word to the left of the cursor
hit Ctrl-U.  Everything to the left of the cursor will be deleted, leaving you with:</p>

<p>I find this useful for just quickly seeing which files contain a search time. I would normally limit the files searched with a command such as :
find . -iname &#39;*php&#39; | xargs grep &#39;string&#39; -sl</p>

<p>Another common search for me, is to just look at the recently updated files:
find . -iname &#39;*php&#39; -mtime -1 | xargs grep &#39;string&#39; -sl</p>

<p>would find only files edited today, whilst the following finds the files older than today:
find . -iname &#39;*php&#39; -mtime +1 | xargs grep &#39;string&#39; -sl</p>
