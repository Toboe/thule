<h1>Serches</h1>

<p>find /samba/share -mtime +10 | awk &#39;{print &quot;mv -f &quot;$1&quot; /backup&quot;$1&quot;&quot;; print &quot;ln -s /backup&quot;$1&quot; &quot;$1&quot;&quot;}&#39; | sh
awk &#39;NR==2&#39; buildinstructins
find . -iname &#39;<em>&#39; -print | sed -n -E -e &#39;s/.</em>mp3/&amp;/p&#39; -e &#39;s/.<em>wav/&amp;/p&#39; -e &#39;s/.</em>wma/&amp;/p&#39; &gt; appo.m3u
find . -iregex &#39;.*.(mp3|wav|wma)&#39; -print &gt; app.m3u
find -size +100M</p>

<h2>Delete all the crap files on desktop before syncing</h2>

<p>find /home/username/Music/ -regextype posix-awk -regex &quot;(.<em>.jpg|.</em>.ini|.<em>.rtf|.</em>.url|.<em>.txt|.</em>.log|.<em>.sfv|.</em>.nfo|
.<em>.md5|.</em>.m3u)&quot; -exec rm -v {} \;</p>

<h2>Print line with DD &amp; next</h2>

<p>awk &#39;/^DD/{f=1;print;next}f{print;exit}&#39; myfile.txt
$ awk &#39;
/^DD/{
print
getline
print
}&#39; myfile.txt
$ sed -n &#39;/^DD/{p;n;p;}&#39; myfile.txt
$ grep -A1 &quot;^DD&quot; myfile.txt</p>

<h2>Line newx to Pattern</h2>

<p>$ awk &#39;/^DD/{f=1;next}f{print;exit}&#39; myfile.txt
$ awk &#39;
/^DD/{
getline
print
}&#39; myfile.txt
$ sed -n &#39;/^DD/{n;p;}&#39; myfile.txt</p>

<h2>Line previous to Pattern</h2>

<h1>wk &#39;/^DD/{print x;print};{x=$0}&#39; myfile.txt</h1>

<p>$ grep -B1 &quot;^DD&quot; myfile.txt</p>

<h3>without patter</h3>

<p>$ awk &#39;/^DD/{print x};{x=$0}&#39; myfile.txt
$ sed -n &#39;/^DD/{g;1!p;};h&#39; myfile.txt</p>

<h2>Previous and newx of PAttern</h2>

<p>$ grep -A1 -B1 &quot;^DD&quot; myfile.txt
$ grep -A1 -B2 &quot;^DD&quot; myfile.txt
awk -v lines=7 &#39;/blah/ {for(i=lines;i;--i)getline; print $0 }&#39; logfile</p>

<p>VIM:
:s/foo/bar/g
    Change each &#39;foo&#39; to &#39;bar&#39; in the current line.
:%s/foo/bar/g   Change each &#39;foo&#39; to &#39;bar&#39; in all lines.
:5,12s/foo/bar/g    Change each &#39;foo&#39; to &#39;bar&#39; for all lines from line 5 to line 12 inclusive.
:&#39;a,&#39;bs/foo/bar/g   Change each &#39;foo&#39; to &#39;bar&#39; for all lines from mark a to mark b inclusive (see Note below).
:&#39;&lt;,&#39;&gt;s/foo/bar/g   When compiled with +visual, change each &#39;foo&#39; to &#39;bar&#39; for all lines within a visual selection. Vim automatically appends the visual selection range (&#39;&lt;,&#39;&gt;) for any ex command when you select an area and enter :. Also, see Note below.
:.,$s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; for all lines from the current line (.) to the last line ($) inclusive.
:.,+2s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; for the current line (.) and the two next lines (+2).
:g/^baz/s/foo/bar/g 
    Change each &#39;foo&#39; to &#39;bar&#39; in each line starting with &#39;baz&#39;.</p>

<p>When searching:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">., *, \, [, ], ^, and $ are metacharacters. 
+, ?, |, {, }, (, and ) must be escaped to use their special function. 
\/ is / (use backslash + forward slash to search for forward slash) 
\t is tab, \s is whitespace 
\n is newline, \r is CR (carriage return = Ctrl-M = ^M) 
\{#\} is used for repetition. /foo.\{2\} will match foo and the two following characters. The \ is not required on the closing } so /foo.\{2} will do the same thing. 
\(foo\) makes a backreference to foo. Parenthesis without escapes are literally matched. Here the \ is required for the closing \). 
</code></pre></div>
<p>When replacing:</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">\r is newline, \n is a null byte (0x00). 
\&amp; is ampersand (&amp; is the text that matches the search pattern). 
\1 inserts the text of the first backreference. \2 inserts the second backreference, and so on. 
</code></pre></div>
<p>Insert newline without entering insert mode
nmap <S-Enter> O<Esc><br>
shift
nmap <CR> o<Esc></p>

<p>each time you hit Ctrl-W, you delete the word to the left of the cursor
hit Ctrl-U.  Everything to the left of the cursor will be deleted, leaving you with:</p>

<p>I find this useful for just quickly seeing which files contain a search time. I would normally limit the files searched with a command such as :
find . -iname &#39;*php&#39; | xargs grep &#39;string&#39; -sl</p>

<p>Another common search for me, is to just look at the recently updated files:
find . -iname &#39;*php&#39; -mtime -1 | xargs grep &#39;string&#39; -sl</p>

<p>would find only files edited today, whilst the following finds the files older than today:
find . -iname &#39;*php&#39; -mtime +1 | xargs grep &#39;string&#39; -sl</p>

<h2>*#########VIM</h2>

<p>:70t.
:tab(gt)
CNTR+P(W) :sp
e ++enc=cp1251
CNTR[BD]v
dt[symbol] or d/[pattern]
deleted using d/D/x/X/c/C/s/S commands.</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&quot;kyy
</code></pre></div>
<p>Or you can append to a register by using a capital letter</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&quot;Kyy
</code></pre></div>
<p>You can then move through the document and paste it elsewhere using</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">&quot;kp
</code></pre></div>
<p>To access all currently defined registers type</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">:reg
</code></pre></div>
<p>$ :set ci</p>

<p>After the option is set, you can use / to search strings(case insensitive)</p>

<p>Title: Include a remote file (in vim)
$ :r scp://yourhost//your/file
Like vim scp://yourhost//your/file but in vim cmds.</p>

<h1>GREP</h1>

<p>grep &#39;pattern1|pattern2&#39; filename
grep -E &#39;pattern1|pattern2&#39; filename
grep -e pattern1 -e pattern2 filename</p>

<p>grep -E &#39;pattern1.<em>pattern2&#39; filename
grep -E &#39;pattern1.</em>pattern2|pattern2.<em>pattern1&#39; filename
grep -E &#39;Manager.</em>Sales|Sales.<em>Manager&#39; empl</em></p>

<p>grep -v &#39;pattern1&#39; filename</p>

<h6>###A</h6>

<p>Title: apache statistics</p>

<p>$ grep &quot;10/Sep/2013&quot; access.log| cut -d[ -f2 | cut -d] -f1 | awk -F: &#39;{print </p>

<h1>$2&quot;:&quot;$3}&#39; | sort -nk1 -nk2 | uniq -c | awk &#39;{ if ($1 &gt; 10) print $0}&#39;</h1>

<h1>AWK</h1>

<p>awk &#39; {print $1,$3} &#39;
Печатает только первый и третий столбцы, используя stdin
awk &#39; {print $0} &#39;
Печатает все столбцы, используя stdin
awk &#39; /&#39;pattern&#39;/ {print $2} &#39;
Печатает только элементы второго столбца, соответствующие шаблону
&quot;pattern&quot;, используя stdin
awk -f script.awk inputfile
Как и sed, awk использует ключ -f для получения инструкций из файла, что
полезно, когда их большое количество и вводить их вручную в терминале
непрактично.
awk &#39; program &#39; inputfile
Исполняет program, используя данные из inputfile
awk &quot;BEGIN { print \&quot;Hello, world!!\&quot; }&quot;
Классическое &quot;Hello, world&quot; на awk
awk &#39;{ print }&#39;
Печатает все, что вводится из командной строки, пока не встретится EOF
! /bin/awk -f
BEGIN { print &quot;Hello, world!&quot; }
Скрипт awk для классического &quot;Hello, world!&quot; (сделайте его исполняемым с
помощью chmod и запустите)
 This is a program that prints \
&quot;Hello, world!&quot;
 and exits
Комментарии в скриптах awk
awk -F &quot;&quot; &#39;program&#39; files
Определяет разделитель полей как null, в отличие от пробела по умолчанию
awk -F &quot;regex&quot; &#39;program&#39; files
Разделитель полей также может быть регулярным выражением
awk &#39;{ if (length($0) &gt; max) max = \
length($0) }
END { print max }&#39; inputfile
Печатает длину самой длинной строки
awk &#39;length($0) &gt; 80&#39; inputfile
Печатает все строки длиннее 80 символов
awk &#39;NF &gt; 0&#39; data
Печатает каждую строку, содержащую хотя бы одно поле (NF означает Number
of Fields)
awk &#39;BEGIN { for (i = 1; i &lt;= 7; i++)
print int(101 * rand()) }&#39;
Печатает семь случайных чисел в диапазоне от 0 до 100
ls -l . | awk &#39;{ x += $5 } ; END \
{ print &quot;total bytes: &quot; x }&#39;
total bytes: 7449362
Печатает общее количество байтов, используемое файлами в текущей
директории
ls -l . | awk &#39;{ x += $5 } ; END \
{ print &quot;total kilobytes: &quot; (x + \
1023)/1024 }&#39;
total kilobytes: 7275.85
Печатает общее количество килобайтов, используемое файлами в текущей
директории
awk -F: &#39;{ print $1 }&#39; /etc/passwd | sort
Печатает отсортированный список имен пользователей
awk &#39;END { print NR }&#39; inputfile
Печатает количество строк в файле, NR означает Number of Rows
awk &#39;NR % 2 == 0&#39; data
Печатает четные строки файла.
ls -l | awk &#39;$6 == &quot;Nov&quot; { sum += $5 }
END { print sum }&#39;
Печатает общее количество байтов файла, который последний раз
редактировался в ноябре.
awk &#39;$1 ~/J/&#39; inputfile
Регулярное выражение для всех записей в первом поле, которые начинаются
с большой буквы j.
awk &#39;$1 ~!/J/&#39; inputfile
Регулярное выражение для всех записей в первом поле, которые не
начинаются с большой буквы j.
awk &#39;BEGIN { print &quot;He said \&quot;hi!\&quot; \to her.&quot; }&#39;
Экранирование двойных кавычек в awk.
echo aaaabcd | awk &#39;{ sub(/a+/, \ &quot;&quot;); print }&#39;
Печатает &quot;bcd&quot;
awk &#39;{ $2 = $2 - 10; print $0 }&#39; inventory
Модифицирует inventory и печатает его с той разницей, что значение
второго поля будет уменьшено на 10.
awk &#39;{ $6 = ($5 + $4 + $3 + $2); print \ $6&#39; inventory
Даже если поле шесть не существует в inventory, вы можете создать его и
присвоить значение, затем вывести его.
echo a b c d | awk &#39;{ OFS = &quot;:&quot;; $2 = &quot;&quot;</p>

<blockquote>
<p>print $0; print NF }&#39;
OFS - это Output Field Separator (разделитель выходных полей) и команда
выведет &quot;a::c:d&quot; и &quot;4&quot;, так как хотя второе поле аннулировано, оно все
еще существует, поэтому может быть подсчитано.
echo a b c d | awk &#39;{ OFS = &quot;:&quot;; \
$2 = &quot;&quot;; $6 = &quot;new&quot;
print $0; print NF }&#39;
Еще один пример создания поля; как вы можете видеть, поле между $4
(существующее) и $6 (создаваемое) также будет создано (как пустое $5),
поэтому вывод будет выглядеть как &quot;a::c:d::new&quot; &quot;6&quot;.
echo a b c d e f | awk &#39;\
{ print &quot;NF =&quot;, NF;
NF = 3; print $0 }&#39;
Отбрасывание трех полей (последних) путем изменения количества полей.
FS=[ ]
Это регулярное выражения для установки пробела в качестве разделителя
полей.
echo &#39; a b c d &#39; |  awk &#39;BEGIN { FS = \
&quot;[ \t\n]+&quot; }
{ print $2 }&#39;
Печатает только &quot;a&quot;.
awk -n &#39;/RE/{p;q;}&#39; file.txt
Печатает только первое совпадение с регулярным выражением.
awk -F\\ &#39;...&#39; inputfiles ...
Устанавливает в качестве разделителя полей \
BEGIN { RS = &quot;&quot; ; FS = &quot;\n&quot; }
{
print &quot;Name is:&quot;, $1
print &quot;Address is:&quot;, $2
print &quot;City and State are:&quot;, $3
print &quot;&quot;
}
Если у нас есть запись вида
&quot;John Doe
1234 Unknown Ave.
Doeville, MA&quot;,
этот скрипт устанавливает в качестве разделителя полей новую строку, так
что он легко может работать со строками.
awk &#39;BEGIN { OFS = &quot;;&quot;; ORS = &quot;\n\n&quot; }
{ print $1, $2 }&#39; inputfile
Если файл содержит два поля, записи будут напечатаны в виде:</p>
</blockquote>

<p>&quot;field1:field2 
field3;field4</p>

<p>...;...&quot;
так как разделитель выходных полей - две новые строки, а разделитель
полей - &quot;;&quot;.
awk &#39;BEGIN {</p>

<blockquote>
<p>OFMT = &quot;%.0f&quot; # print numbers as \
integers (rounds)
print 17.23, 17.54 }&#39;
Будет напечатано 17 и 18 , так как в качестве выходного формата (Output
ForMaT) указано округление чисел с плавающей точкой до ближайших целых
значений.
awk &#39;BEGIN {
msg = &quot;Dont Panic!&quot;
printf &quot;%s\n&quot;, msg
} &#39;
Вы можете использовать printf практически так же, как и в C.
awk &#39;{ printf &quot;%-10s %s\n&quot;, $1, \
$2 }&#39; inputfile
Печатает первое поле в виде строки длиной 10 символов, выровненной по
левому краю, а затем второе поле в обычном виде.
awk &#39;{ print $2 &gt; &quot;phone-list&quot; }&#39; \inputfile
Простой пример извлечения данных, где второе поле записывается под
именем &quot;phone-list&quot;.
awk &#39;{ print $1 &gt; &quot;names.unsorted&quot;
       command = &quot;sort -r &gt; names.sorted&quot;
       print $1 | command }&#39; inputfile
Записывает имена, содержащиеся в $1, в файл, затем сортируем и выводим
результат в другой файл.
awk &#39;BEGIN { printf &quot;%d, %d, %d\n&quot;, 011, 11, \
0x11 }&#39;
Will print 9, 11, 17
if (/foo/ || /bar/)
   print &quot;Found!&quot;
Простой поиск для foo или bar.
awk &#39;{ sum = $2 + $3 + $4 ; avg = sum / 3
print $1, avg }&#39; grades
Простые арифметические операции (в большинстве похожи на C)
awk &#39;{ print &quot;The square root of&quot;, \
$1, &quot;is&quot;, sqrt($1) }&#39;
2
The square root of 2 is 1.41421
7
The square root of 7 is 2.64575
Простой расширяемый калькулятор
awk &#39;$1 == &quot;start&quot;, $1 == &quot;stop&quot;&#39; inputfile
Печатает каждую запись между start и stop.
awk &#39;
BEGIN { print &quot;Analysis of \&quot;foo\&quot;&quot; }
/foo/ { ++n }
END { print &quot;\&quot;foo\&quot; appears&quot;, n,\
 &quot;times.&quot; }&#39; inputfile
Правила BEGIN и END исполняются только один раз, до и после каждой
обработки записи.
echo -n &quot;Enter search pattern: &quot;
read pattern
awk &quot;/$pattern/ &quot;&#39;{ nmatches++ }
END { print nmatches, &quot;found&quot; }&#39; inputfile
Search using shell
if (x % 2 == 0)
print &quot;x is even&quot;
else
print &quot;x is odd&quot;
Простое условие. awk, как и C, также поддерживает операторы ?:.
awk &#39;{ i = 1
  while (i &lt;= 3) {
    print $i
    i++
  }
}&#39; inputfile
Печатает первые три поля каждой записи, по одной в строке.
awk &#39;{ for (i = 1; i &lt;= 3; i++)
  print $i
}&#39;
Печатает первые три поля каждой записи, по одной в строке.
BEGIN {
if ((&quot;date&quot; | getline date<em>now) &lt;= 0) {
  print &quot;Can&#39;t get system date&quot; &gt; \
&quot;/dev/stderr&quot;
  exit 1
}
print &quot;current date is&quot;, date</em>now
close(&quot;date&quot;)
}
Выход с кодом ошибки, отличным от 0, означает, что что-то идет не так.
Пример:
awk &#39;BEGIN {
for (i = 0; i &lt; ARGC; i++)
print ARGV[i]
}&#39; file1 file2
Печатает awk file1 file2
for (i in frequencies)
delete frequencies[i]
Удаляет элементы в массиве
foo[4] = &quot;&quot;
if (4 in foo)
print &quot;This is printed, even though foo[4] \
is empty&quot;
Проверяют элементы массива
function ctime(ts, format)
{
  format = &quot;%a %b %d %H:%M:%S %Z %Y&quot;
  if (ts == 0)
  ts = systime()
  # use current time as default
  return strftime(format, ts)
}
awk-вариант функции ctime() в C. Так вы можете определять свои
собственные функции в awk.
BEGIN { <em>cliff</em>seed = 0.1 }
function cliff<em>rand()
{
  _cliff</em>seed = (100 * log(<em>cliff</em>seed)) % 1
  if (<em>cliff</em>seed &lt; 0)
    <em>cliff</em>seed = - <em>cliff</em>seed
  return <em>cliff</em>seed
}
Генератор случайных чисел Cliff.
cat apache-anon-noadmin.log | \
awk &#39;function ri(n) \
{  return int(n*rand()); }  \
BEGIN { srand(); }  { if (! \
($1 in randip)) {  \
randip[$1] = sprintf(&quot;%d.%d.%d.%d&quot;, \
ri(255), ri(255)\
, ri(255), ri(255)); } \
$1 = randip[$1]; print $0  }&#39;
Анонимный лог Apache (IP случайные)</p>
</blockquote>
