isql -v mymssql <логин> <пароль>   

create database link ODBC2 connect to "oracle2" identified by "oracle2" using 'mssql'
        select * from Region@ODBC2;
SELECT table_name FROM dba_tables WHERE table_name LIKE 'HS%';
SELECT view_name FROM dba_views WHERE view_name LIKE 'HS%';
@rdbms/admin/caths.sql;

Select *
from v$parameter
where name like 'global_names%';


listener_PROD188_TEST =
  (ADDRESS_LIST =
        (ADDRESS= (PROTOCOL= IPC)(KEY= PROD188))
        (ADDRESS= (PROTOCOL= TCP)(Host= pulse)(Port= 1555))
  )

SID_LIST_listener_PROD188_TEST =
  (SID_LIST =
    (SID_DESC =
      (ORACLE_HOME= /restore/PROD18810gR2)
      (SID_NAME = PROD188)
    )
  )

> sqlplus /nolog
SQL> connect / as sysdba
SQL> shutdown abort
SQL> startup nomount
SQL> alter database mount;
SQL> alter database open;

For checking on trailing trash:

    $ echo $ORACLE_HOME
    $ /app/oracle/817/ << Incorrect

    $ echo $ORACLE_HOME
    $ /app/oracle/817 << Correct

For ORACLE_SID:

    $ echo $ORACLE_SID
    $ ora817

    $ ps -ef | grep smon
    ora_smon_ORA817


    find the sessions for the users/schema , as a DBA use : select sid,serial# from v$session where username = '<user_schema>'

    Then kill them with : alter system kill session '<sid>,<serial#>'

A query that produces ready-built kill-statements could be

    select 'alter system kill session ''' || sid || ',' || serial# || ''';' from v$session where username = '<your_schema>'

This will return one kill statement per session for that user – something like:

alter system kill session '375,64855';

alter system kill session '346,53146';

    Now Drop the user : drop user <user_schema_name> cascade;


List all users/schema
         SET PAGESIZE 50
         SELECT DISTINCT USERNAME FROM DBA_USERS;
 
List ONLY your tables
         SET PAGESIZE 80
         COL TABLE__NAME FORMAT a30;
         COL TABLE_TYPE FORMAT a30;
         SELECT * FROM CAT;

List the Oracle Tablespaces and free space
         SELECT * from v$TABLESPACE;

List the free space for all Oracle Tablespaces within a Database
         SELECT * from DBD_FREE_SPACE where TABLESPACE_NAME = 'IATOR';

List the space ALREADY USED for a specific Oracle Tablespace
         SELECT * from DBA_SEGMENTS where TABLESPACE_NAME = 'myTABLESPACE';

List extents for segments
         SELECT TABLESPACE_NAME, count(*), max(blocks), sum(blocks) from dba_free_space group by TABLESPACE_name;

See all the tables you have access to:
         SET PAGESIZE 90
         COLUMN "OBJECT NAME" format a26
         COLUMN "OBJECT TYPE" format a20
         SELECT object_name    "OBJECT NAME",
                object_type    "OBJECT TYPE"
         FROM
                user_objects
         WHERE
                object_type = 'TABLE';

See your TABLESPACE
         SELECT TABLESPACE_NAME from ALL_TABLES where TABLE_NAME = '<your_table>'


#jobs created
select * from dba_SCHEDULER_JOBS
#jobs running
select * from dba_scheduler_running_jobs

#drop scheduler jobs
select 'BEGIN DBMS_SCHEDULER.DISABLE(''' || owner ||'.'||job_name ||'''); END;'


from dba_SCHEDULER_JOBS

cd $ORACLE_HOME/OPatch
opatch lsinventory
opatch lsinventory -invPtrLoc /etc/oraInst.loc

select comp_id, version from dba_registry;
SELECT * FROM V$VERSION;


#MS SQL SERVER

#
deattach -> attache помогло

RESTORE FILELISTONLY
FROM DISK = 'D:BackUpYourBaackUpFile.bak'
GO

Step 2: Use the values in the LogicalName Column in following Step.
----Make Database to single user Mode
ALTER DATABASE YourDB
SET SINGLE_USER WITH
ROLLBACK IMMEDIATE

----Restore Database
RESTORE DATABASE YourDB
FROM DISK = 'D:BackUpYourBaackUpFile.bak'
WITH MOVE 'YourMDFLogicalName' TO 'D:DataYourMDFFile.mdf',
MOVE 'YourLDFLogicalName' TO 'D:DataYourLDFFile.ldf'

/*If there is no error in statement before database will be in multiuser
mode.
If error occurs please execute following command it will convert
database in multi user.*/
ALTER DATABASE YourDB SET MULTI_USER
GO


osql -E -S ComputerName\InstanceName
1> USE Northwind

2> GO

1> SELECT SupplierID, CompanyName

2> FROM Suppliers

3> WHERE CompanyName LIKE 'T%'

4> GO
sp_help tablename
sp_help foo
sp_help


select * from NLS_DATABASE_PARAMETERS;
select * from NLS_instance_PARAMETERS;
select * from NLS_session_PARAMETERS;
select * from sys.V_$NLS_VALID_VALUES a where a.isdeprecated != 'FALSE' ;

select * from sys.V_$NLS_VALID_VALUES;



    -- Here we use from 1-jan-2012 to 30-aug-2012
     
    SELECT TO_DATE(TRUNC(DBMS_RANDOM.VALUE(TO_CHAR(TO_DATE('1-jan-2012'),'J'),TO_CHAR(TO_DATE('30-aug-2012'),'J'))),'J') FROM DUAL;
     
     
    -- To produce a random date within a specified number of days from today:
     
    -- Here we use two weeks (14 days) allowing dates in the past as well as the future
     
    SELECT SYSDATE+DBMS_RANDOM.VALUE(-14,14) FROM DUAL;
     
     
    -- Here we use three weeks (21 days) allowing dates only in the future
     
    SELECT SYSDATE+DBMS_RANDOM.VALUE(1,14) FROM DUAL;
     
     
    -- Here we use a year (365 days) allowing dates only in the past
     
    SELECT SYSDATE+DBMS_RANDOM.VALUE(-365,0) FROM DUAL;




sqlplus '/ as sysdba'
STARTUP
CREATE SPFILE FROM PFILE;
SHUTDOWN IMMEDIATE;
STARTUP
SHOW PARAMETER SPFILE



D:\oracle\10.2.0\database\SPFILEIPSOFT.ORA


ipsoft.__java_pool_size=8388608
ipsoft.__large_pool_size=8388608
ipsoft.__shared_pool_size=142606336
ipsoft.__streams_pool_size=0
*.audit_file_dest='D:\oracle\admin\IPSOFT\adump'
*.background_dump_dest='D:\oracle\admin\IPSOFT\bdump'
*.compatible='10.2.0.1.0'
*.control_files='D:\oracle\oradata\IPSOFT\control01.ctl','D:\oracle\oradata\IPSOFT\control02.ctl','D:\oracle\oradata\IPSOFT\control03.ctl'
*.core_dump_dest='D:\oracle\admin\IPSOFT\cdump'
*.db_block_size=16384
*.db_domain=''
*.db_file_multiblock_read_count=16
*.db_name='IPSOFT'
*.db_recovery_file_dest='D:\oracle\flash_recovery_area'
*.db_recovery_file_dest_size=17179869184
*.dispatchers='(PROTOCOL=TCP) (SERVICE=IPSOFTXDB)'
*.job_queue_processes=10
*.nls_language='RUSSIAN'
*.nls_territory='RUSSIA'
*.open_cursors=300
*.pga_aggregate_target=670040064
*.processes=300
*.query_rewrite_integrity='stale_tolerated'
*.remote_login_passwordfile='EXCLUSIVE'
*.sga_max_size=1887436800
*.sga_target=1686110208
*.undo_management='AUTO'
*.undo_tablespace='UNDOTBS1'
*.user_dump_dest='D:\oracle\admin\IPSOFT\udump'


сделайте так
1. Прячите D:\oracle\10.2.0\database\SPFILEIPSOFT.ORA подальше
2.

 create spfile from pfile='путь к initIPSOFT.ora';

3. shu immediate;
4. startup;
5. если после пункта 4 возникли траблы(не запустилось, не так работает.....), то

shu immediate;
startup pfile='путь к initIPSOFT.ora';

alter system set sga_max_size=<value> scope=spfile|memory|both;o


     Or In Another Way :
    sql>alter system set sga_target=12G scope=spfile sid='*';
    sql>alter system set sga_max_size=16G scope=spfile sid='*';
    sql>alter system set sga_max_size=16G scope=spfile ;
    sql>alter system set sga_target=12G scope=spfile;

     PGA :

    sql>alter system set pga_aggregate_target=4G scope =spfile sid='*';
    sql>alter system set pga_aggregate_target=4G scope=both;



    shutdown database PROD (two instances should be shut down)

     $>srvctl stop database -d PROD

    $>srvctl START database -d PROD



Check The New Size For Both Instance By :

    Show parameter sga ; 


# sysctl -a | grep shmmax
kernel.shmmax = 8G

SQL> create pfile='/tmp/pfile-backup' from spfile;
SQL> alter system set sga_max_size=8G sid='*' scope=spfile;

$ srvctl stop instance -d racdb -i racdb1 -o immediate
$ srvctl start instance -d racdb -i racdb1

if error... check alert log on racdb1 and solve(don't forget to change "SGA_TARGET" as well), if no error stop/start on racdb2

$ srvctl stop instance -d racdb -i racdb2 -o immediate
$ srvctl start instance -d racdb -i racdb2

Check:
select * from v$sgainfo;
select * from v$sga;


