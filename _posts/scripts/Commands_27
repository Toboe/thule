Title: 100% rollback files to a specific revision
$ git reset --hard <>commidId> && git clean -f
Title: Google text-to-speech in mp3 format
$ t2s() { wget -q -U Mozilla -O $(tr ' ' _ <><><> "$1"| cut -b 1-15).mp3 
"http://translate.google.com/translate_tts?ie=UTF-8&tl=en&q=$(tr ' ' + <><><> 
"$1")"; }

Usage: t2s 'How are you?'

Nice because it automatically names the mp3 file up to 15 characters
Title: cpanel umount virtfs mounts
$ for i in `cat /proc/mounts | grep /home/virtfs | cut -d ? ? -f 2 ` ; do 
umount $i; done
Title: Day 5: I wrote a kernel module!!!

I WROTE A KERNEL MODULE. It doesn’t do anything useful or anything, but still! 
This is a pretty quick post because there was an awesome talk today by Mel Chua[1]
and I need to sleep.

The source for the module is at https://gist.github.com/jvns/6878994[2]

It intercepts any incoming packets and prints “Hello packet” to the kernel log 
for each one. It uses a the Netfilter framework, which I learned about from 
this document[3].

To install it, you can run:
12 $ make$ insmod hello-packet.ko

and then
1 $ rmmod hello-packet.ko

to remove it.

http://kernelnewbies.org[4] is a fantastic resource and I’ve been learning a 
lot from it.

Some more resources:

  * Instructions for writing a “hello world” kernel module[5]
  * Some examples if you’re interested in learning about rootkits: 1[6], 2[7], 
    3[8], 4 (pdf)[9]

(I think I’m going to work on writing a rootkit tomorrow. eee.)

Some things I learned along the way:

  * You can’t use malloc inside the kernel (?!!?). This is because anything 
    that’s used in the kernel needs to be defined in the kernel, and malloc is 
    in glibc. This seems obvious in retrospect, but kind of blew my mind
  * Similarly, you can’t use anything from glibc in the kernel.
  * There are apparently things called kmalloc and vmalloc that you can use 
    instead. I don’t know what these are yet.
  * It is really easy to write a firewall that doesn’t let any packets in or 
    out – just replace NF_ACCEPT with NF_DROP in my kernel module.


Title: Emulate tail using awk.

$ awk '{ c=NR%n; a[c]=$0 } END{ for(i=1; i<>=n; i++) print a[(c+i)%n] }' n=10 
File

This awk codes emulates tail. For efficiency the awk code uses a circular 
array, which stores only N number of records.


by David Winterbottom (codeinthehole.com[5])
[image 6]

Title: Execute ls -lah every one second
$ watch --interval 1 ls -lah
Use this command if you want to control the size of the files in human 
readable, every one second.
Title: Get a list of all TODO/FIXME tasks left to be done in your project
$ alias tasks='grep --exclude-dir=.git -rEI "TODO|FIXME" . 2>/dev/null'

Place this in your .bashrc (or run it once) to set the `tasks` alias. Next time
you enter `tasks` into a terminal, it will give you a list of all TODO and 
FIXME comments in the current directory and child directories, giving you a 
quick overview of what you still have to do!
Title: Google text-to-speech in mp3 format

$ t2s() { wget -q -U Mozilla -O $(tr ' ' _ <><><> "$1"| cut -b 1-15).mp3 
"http://translate.google.com/translate_tts?ie=UTF-8&tl=en&q=$(tr ' ' + <><><> 
"$1")"; }

Usage: t2s 'How are you?'

Nice because it automatically names the mp3 file up to 15 characters
Title: make GNU find follow symbolic links

$ find -L /home/sonic/archive -name '*gz' -type f

If /home/sonic/archive/ was a symlink to /backup/sonic/archive it would follow 
the links and give you the file listing. By default find will NOT follow 
symbolic links. The default behavior for the find command is to treat the 
symlinks as literal files.

I discovered this when trying to write a script run via cron to delete files 
with a modification time older than X days. The easiest solution was to use:

/usr/bin/find -L /home/sonic/archive -name '*gz' -type f -mtime +14 -exec rm 
'{}' \;
Title: poor man's vpn
$ sshuttle --dns -vvr user@server 0/0
Title: Prepend a text to a file.

$ sed -i 's/^/ls -l /' output_files.txt

The original command is great, but I often want to prepend to every line.
Title: rm filenames with spaces
$ find garbage/ -type f -delete

I _think_ you were trying to delete files whether or not they had spaces. This 
would do that. You should probably be more specific though.

Title: [vim] Clear a file in three characters (plus enter)
$ :%d

% selects every line in the file. 'd' deletes what's selected. It's a pretty 
simple combination.

Title: [vim] Clear trailing whitespace in file

$ :%s/\s\+$//

% acts on every line in the file.

\s matches spaces.

\+ matches one or more occurrences of what's right behind it.

Character '$' matches end-of-line.
Title: vi show line numbers
$ :set number

Prints line numbers making it easier to see long lines that wrap in your 
terminal and extra line breaks at the end of a file.

:set nu

works too.
